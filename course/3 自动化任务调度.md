# 手把手教你写IAST系列③【自动化任务调度】

> 本章节你需要了解Golang、Python、Redis、MySQL；burpsuite pro、sqlmap，将学习到：
>
> 1. 结合章节1，获取目标流量
> 2. 结合章节2，对目标进行SQL注入和Web漏洞扫描
> 3. 如何通过Go调用burpsuite、sqlmap，并通过接口/rest-api，提交流量安全扫描
> 4. 可能了解到如何进行权限漏洞检测：未授权访问、水平越权、垂直越权检测

目标：

1. 通过Golang获取Redis中的Web流量，封装成sqlmap和burpsuite需要的格式，提交扫描并获取扫描结果
2. 进阶：实现权限相关漏洞检测，同时自动化获取流量，提交扫描，获取结果

相关文章：

《[巧用 IAST摸鱼](https://github.com/one-iast/practice/blob/main/course/0%20%E5%B7%A7%E7%94%A8%20IAST%E6%91%B8%E9%B1%BC.md)》

《[手把手教你写IAST系列①【代理流量获取】](https://github.com/one-iast/practice/blob/main/course/1%20%E4%BB%A3%E7%90%86%E6%B5%81%E9%87%8F%E8%8E%B7%E5%8F%96.md)》

《[手把手教你写IAST系列②【扫描工具选取】](https://github.com/one-iast/practice/blob/main/course/2%20%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7%E9%80%89%E5%8F%96.md)》

## 前言

在前一章节《[手把手教你写IAST系列②【扫描工具选取】](https://github.com/one-iast/practice/blob/main/course/2%20%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7%E9%80%89%E5%8F%96.md)》中，我们已经能够对目标进行手动提交SQL注入和Web漏洞扫描任务，并手动获取结果。

接下来，我们将通过Go实现自动化任务调度。

## 依赖

需要先学习章节1和章节2的内容，否则后续操作无法进行：

[前置代理](https://github.com/one-iast/practice/tree/main/front-proxy)，IAST Front Proxy，获取目标流量，需要先学习章节1《[手把手教你写IAST系列①【代理流量获取】](https://github.com/one-iast/practice/blob/main/course/1%20%E4%BB%A3%E7%90%86%E6%B5%81%E9%87%8F%E8%8E%B7%E5%8F%96.md)》

[扫描工具选取]，需要先学习章节2《[手把手教你写IAST系列②【扫描工具选取】](https://github.com/one-iast/practice/blob/main/course/2%20%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7%E9%80%89%E5%8F%96.md)》

Golang >= 1.20，使用go进行任务调度和分发；*可使用Python代替，但后续没有Python的demo，且后续平台也是基于go实现*

部分依赖在前序章节已有说明，这里不再展开；依赖安装和配置可自行查询资料。

## 需求分析

能够以简单的方式自动化获取流量并调度执行。

## 架构设计

本章节开始，会涉及到开发内容，将进行架构分析和设计，需求分析已经在前面章节完成。

前序章节中，我们把流量保存到Redis中，后续需要从Redis中取流量出来，分别封装成sqlmap和burpsuite需要的流量，并提交到扫描，通过轮询扫描状态（是否完成），获取结果并删除任务（停止服务）。

稍微整理可以得到以下数据流：

```
归一化md5    去重流量    扫描器数据包     扫描中的任务     扫描结果
target  ->  flow   ->  packet    ->   task      ->   result
```

> 为什么不直接用MQ？demo阶段，简单为主，同时减少依赖，降低学习成本

架构图及流程图

其实就跟《[巧用 IAST摸鱼](https://github.com/one-iast/practice/blob/main/course/0%20%E5%B7%A7%E7%94%A8%20IAST%E6%91%B8%E9%B1%BC.md)》里的架构差不多，只不过调度会稍微简单一点，全部通过redis实现

![架构图](https://github.com/one-iast/practice/assets/30471543/f3bbbcfd-18ba-4d7f-a8c4-aeb6930392f0)

架构设计完成后，后续根据架构进行功能开发和调整。

## 前置操作

### 启动前置代理

根据章节1《[手把手教你写IAST系列①【代理流量获取】](https://github.com/one-iast/practice/blob/main/course/1%20%E4%BB%A3%E7%90%86%E6%B5%81%E9%87%8F%E8%8E%B7%E5%8F%96.md)》，启动前置代理

### 启动漏洞靶场/环境

根据章节2《[手把手教你写IAST系列②【扫描工具选取】](https://github.com/one-iast/practice/blob/main/course/2%20%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7%E9%80%89%E5%8F%96.md)》，启动靶场环境

假设靶场已经运行

本地IP为：`http://localhost:8888`

非127的IP为：`http://192.168.1.20:8888`

**注意：后续需要保持前置代理和靶场启动，需要通过非127的IP访问靶场，127的流量有可能不通过代理，导致前置代理获取不到流量**

## 接口封装

### go http client封装

参考已提交的代码，这里不展开说明

### go封装sqlmapapi接口访问

> 仅实现demo阶段需要的接口

通过封装之后的go http client进一步封装sqlmap api，使go能够通过http方式调用sqlmap api

以新建任务为例

```go
func NewTask() (string, error) {
	httpData := &entity.HttpData{Api: baseApi + "/task/new", HttpMethod: "GET"}
	body, _, err := http.DoRequest(httpData)
	if err != nil {
		return "", err
	}
	result := &entity.NewSqlmapTaskResp{}
	err = sonic.Unmarshal(body, &result)
	if err != nil {
		return "", err
	}
	return result.Taskid, nil
}
```

### go封装burp-rest-api接口访问

> 仅实现demo阶段需要的接口

**burpsuite需要清空sitemap才能避免下次启动active scan时，重复扫描已扫过的url，但burp官方没有提供清空sitemap的接口，所以burp-rest-api扩展也是没有这个接口，只能通过重启burpsuite解决重复扫描的问题**

所以对于burpsuite扫描，最好的解决方案是，等指定目标的全部流量（或大数量的流量，减少重启耗时）都经过代理后，启动burp发起扫描，等burpsuite自己调度扫描任务，最后获取结果，结束任务

通过封装之后的go http client进一步封装burp-rest-api，使go能够通过http方式调用burp-rest-api（burpsuite）

以获取版本为例

```go
func GetVersion() (*entity.BurpVersion, error) {
	httpData := &entity.HttpData{Api: baseApi + "/versions", HttpMethod: "GET"}
	body, _, err := http.DoRequest(httpData)
	if err != nil {
		return nil, err
	}
	result := &entity.BurpVersion{}
	err = sonic.Unmarshal(body, &result)
	if err != nil {
		return nil, err
	}
	return result, nil
}
```

## 单独调度

封装完各个接口之后，就可以进行任务调度了，大概思路是将手动方式转换为自动化，同时补充部分在手动中缺失的流程。

sqlmapapi可以作为服务使用（不需要重启）；burp-rest-api任务都要重启

### 自动化扫描SQL注入漏洞-调用sqlmap

```go
// 获取redis中的流量，封装成sqlmap任务数据
util.PacketFlow()
// 提交sqlmap扫描任务
sqlmap.SubmitTask()
// 获取扫描结果
sqlmap.GetTaskResult()
// 打印扫描结果
sqlmap.ShowTaskResult()
```

### 自动化扫描Web漏洞-调用burpsuite

```go
// 获取redis中的流量，封装成burpsuite任务数据
util.PacketFlow()
// 提交burpsuite扫描任务
burpsuite.SubmitTask()
// 获取扫描结果
burpsuite.GetTaskResult()
// 打印扫描结果
burpsuite.ShowTaskResult()
```

## 联合执行

> 后续代码仅作为学习参考使用，无法用于生产。

在上述章节，我们手动通过sqlmapapi和burp-rest-api调用对应工具，完成了SQL注入漏洞检测和Web检测，接下来将通过代码，实现这部分功能，手动->自动。

参考iast-demo项目的README文档。

burpsuite-scanner.go

```go
type Runner struct {
}

func (r *Runner) Run() {
	fmt.Println("iast-burpsuite start")
	s := gocron.NewScheduler(time.Local)
	_, err := s.Every(5).Second().Do(util.PacketFlow)
	_, err = s.Every(30).Second().Do(SubmitTask)
	_, err = s.Every(10).Second().Do(GetTaskResult)
	_, err = s.Every(10).Second().Do(ShowTaskResult, "all")
	if err != nil {
		log.Fatal(err)
	}
	s.StartAsync()
}
```

sqlmap-scanner.go

```go
type Runner struct {
}

func (r *Runner) Run() {
	fmt.Println("iast-sqlmap start")
	s := gocron.NewScheduler(time.Local)
	_, err := s.Every(5).Second().Do(util.PacketFlow)
	_, err = s.Every(10).Second().Do(SubmitTask)
	_, err = s.Every(10).Second().Do(GetTaskResult)
	_, err = s.Every(10).Second().Do(ShowTaskResult)
	if err != nil {
		log.Fatal(err)
	}
	s.StartAsync()
}
```

main.go

```go
func main() {
	config.LoadConfig(".")
	if config.CFG.Sqlmap.Enable {
		go util.Run(new(sqlmap.Runner))
	}
	if config.CFG.Burpsuite.Enable {
		go util.Run(new(burpsuite.Runner))
	}
	util.KeepAlive()
}
```

## 对靶场进行权限相关漏洞检测-自定义实现

由于篇幅原因，这部分功能暂时不展开，只说明关键技术点

1. 未授权访问：通过篡改请求头信息（去除认证信息，如cookie），判断能否正常获取数据。
2. 垂直越权：访问高权限用户api时，使用低权限用户认证凭据替换并访问，判断能否正常获取数据。
3. 水平越权：访问用户私有数据，篡改用户标识，判断能否正常获取数据。

通过多种方式判断修改后访问的数据是否与未修改访问的相同。

当然，除了权限检测，插件检测也是可以的，这里也暂时不展开。

## 优化空间

1. 需要配置各种环境，安装依赖，非常麻烦
2. 需要手动启动前置代理，比较麻烦
3. burpsuite激活仅本地可用，无法复用到其它环境
4. 仅适用于安全专业人员，其他非安全专业人员可能需要较长的学习过程才会用

‍
